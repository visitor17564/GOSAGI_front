<p align="center">
  <img src="https://postfiles.pstatic.net/MjAyNDAyMDFfOTcg/MDAxNzA2Nzc2MzgwODY5.o4trv2TkTycT-E_-bBYnlpI5-BPZeB0eMp7TdybUxPQg.PCetaFXlL-Jc8eieJ-OT13ooa7WEjBHDMpod1nfUxbog.PNG.dkdud530/gola.png?type=w966" width="200" alt="Nest Logo" />
</p>

<p align="center">
  <img  src="https://img.shields.io/badge/Node.js-339933?style=flat-square&logo=Node.js&logoColor=white">
  <img  src="https://img.shields.io/badge/NestJS-E0234E?style=flat-square&logo=NestJS&logoColor=white">
  <img  src="https://img.shields.io/badge/Typescript-3178c6?style=flat-square&logo=typescript&logoColor=white">
  <img src="https://img.shields.io/badge/TypeORM-FE3A2F?style=flat-square&logo=TypeORM&logoColor=white">
  <img src="https://img.shields.io/badge/Axios-5A29E4?style=flat-square&logo=Axios&logoColor=white">
  <img src="https://img.shields.io/badge/JWT-000000?style=flat-square&logo=JSON%20web%20tokens&logoColor=white">
  <img src="https://img.shields.io/badge/Puppeteer-40B5A4?style=flat-square&logo=Puppeteer&logoColor=white">
  <img src="https://img.shields.io/badge/Toss%20Payment-0055FF?style=flat-square&logo=Toss&logoColor=white">
  <img src="https://img.shields.io/badge/Google%20Login-4285F4?style=flat-square&logo=Google&logoColor=white">
  <img src="https://img.shields.io/badge/Naver%20Login-03C75A?style=flat-square&logo=Naver&logoColor=white">
  <img src="https://img.shields.io/badge/Kakao%20Login-FFCD00?style=flat-square&logo=Kakao&logoColor=white">
  <img src="https://img.shields.io/badge/Redis-DC382D?style=flat-square&logo=Redis&logoColor=white">
  <img src="https://img.shields.io/badge/Docker-2496ED?style=flat-square&logo=Docker&logoColor=white">
  <img src="https://img.shields.io/badge/GitHub_Actions-2088FF?style=flat-square&logo=GitHub-Actions&logoColor=white">
  <img src="https://img.shields.io/badge/JMeter-9CCA42?style=flat-square&logo=Apache%20JMeter&logoColor=white">
  <img src="https://img.shields.io/badge/Winston-FF6B6B?style=flat-square&logo=Winston&logoColor=white">
<img src="https://img.shields.io/badge/Elasticsearch-005571?style=flat-square&logo=Elasticsearch&logoColor=white">
<img src="https://img.shields.io/badge/Kibana-005571?style=flat-square&logo=Kibana&logoColor=white">
  <img src="https://img.shields.io/badge/EC2-FF9900?style=flat-square&logo=amazon-aws&logoColor=white">
  <img src="https://img.shields.io/badge/Load%20Balancer-FF9900?style=flat-square&logo=amazon-aws&logoColor=white">
  <img src="https://img.shields.io/badge/Route%2053-FF9900?style=flat-square&logo=amazon-aws&logoColor=white">
  <img src="https://img.shields.io/badge/AWS_S3-569A31?style=flat-square&logo=Amazon-S3&logoColor=white">
</p>
<br>

<details>
  <summary style="font-size: 30px;"><strong>👀 프로젝트 간단 소개</strong></summary>

<img src="./readme/Untitled.png">

```
💡 10만원 기부하고 13만원 돌려받는 답례품들을 둘러보세요!

원한다면 기부하고 상품이 마음에 든다면 장바구니에 담고 구매해보세요!
```

### **✔️ 프로젝트 명** : gola(골라)

### **✔️ 소개**

- 한 줄 정리 : 고향사랑 기부 제도 답례품을 소개하고 상품이 괜찮아 **다시 구매하고싶은 사람들은 구매도 가능한 쇼핑몰**
  - [원본 고향사랑기부 공식 사이트 구경하기](https://www.ilovegohyang.go.kr/goods/index-main.html)

### **✔️** 프로젝트 주제 선택 배경

- 조회, 등록, 찜, 장바구니, 문의, 댓글, 결제, 배송, 셀러, 관리자 등 다양한 API를 기획, 구현해 볼 수 있는 키워드이기에 선택했습니다.
  <details>
      <summary>뜬금없이 고향사랑기부제?(정말 궁금하신 분만 눌러보세요)</summary>

  - 고향사랑기부제도는 20년전 일본이 **인구감소**와 **저성장시대**에 돌입했을 때 **지역소멸 완화**를 위해 시작한 제도입니다.
  - 1년차인 **2008년에 약 80억엔(현재기준 약 700억)정도** 기부금이 모였고 **20년쯤 뒤에는 약 8000억(약 7조) 수준**으로 성장했습니다.(100배성장)
  - 그리고 그 성장동력에는 **답례품 경쟁**으로 인한 소액기부의 비중이 큰 정도가 아니라 **대다수를 차지**했습니다.

  <div style="display:flex">
  <img src="./readme/Untitled 1.png" width="50%">
  <img src="./readme/Untitled 2.png" width="50%">
  </div>

  ```
  💡 그리고 보시다시피 대한민국의 인구감소, 저성장, 지역소멸 위기는 저때의 일본보다 더 절망적입니다.
  ```

  - 대한민국은 **2023년에 처음으로 이 제도를 도입**했으며 **`1년차를 약 650원의 성과로 마감`**했습니다.(잘 모르시는게 당연합니다)
  - 총액 650억에 52만 5천건이면 **1명당 평균 13만원을 기부한 셈**입니다. 즉, 일본과 같이 **답례품 위주의 소액기부 비중이 매우 높다는 것**을 의미합니다.

    <img src="./readme/Untitled 3.png">

  ```
  💡 이 제도는 점점 더 장려될 것이고, 시장이 커지고 관련 서비스들이 늘어날 가능성을 가지고 있다고 생각합니다.
  어느순간 모두 알게될 컨텐츠를 기반으로 한 유사 서비스를 미리 기획하고 경험해보는 것은 유의미하다고 생각했습니다.
  ```

  </details>

</details>

<br>

<details>
  <summary style="font-size: 30px;"><strong>🎞️ 시연영상 / 이용안내</strong></summary>
  
  ### 시연영상

[![YouTube 비디오](https://img.youtube.com/vi/3P4Wx0NaEwQ/0.jpg)](https://www.youtube.com/watch?v=3P4Wx0NaEwQ)

### 이용안내/체험하기

- [직접 체험하기](https://front.gosagi.com)
- [홈페이지 이용안내 바로가기](https://lanlanlooo.notion.site/1112584491d84cdfa087ae31424e8c9f)
</details>

<br>

<details>
  <summary style="font-size: 30px;"><strong>🖼️ 서비스 아키텍쳐</strong></summary>
  <img src="./readme/Untitled 4.png">
</details>

<br>

<details>
  <summary style="font-size: 30px;"><strong>🛠️사용 기술 스택</strong></summary>
  <table>
  <thead>
    <tr>
      <th>사용 기술</th>
      <th>도입 이유</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>NestJS</td>
      <td>기본 개발 언어로 모듈을 자동으로 생성하고 관리</td>
    </tr>
    <tr>
      <td>MySQL(aws rds)</td>
      <td>쇼핑몰 특성 상 데이터가 많고 cascade가 필요한 관계가 존재하기 때문에 관계형 데이터베이스인 mysql을 기본 dbms로 선택</td>
    </tr>
    <tr>
      <td>TypeORM</td>
      <td>typeorm으로 백엔드에서 sql을 처리</td>
    </tr>
    <tr>
      <td>Redis Cloud</td>
      <td>refresh 토큰이나 최근 본 상품 보기 등의 기능을 구현할 때 메인 DB에 계속 접근하고 내용을 쌓인 채로 두는 것보단 인덱싱이 빠르고 삭제 가능한 캐시 데이터를 사용할 수 있는 REDIS를 사용</td>
    </tr>
    <tr>
      <td>AWS S3</td>
      <td>이미지를 저장하기 위해 사용</td>
    </tr>
    <tr>
      <td>JWT</td>
      <td>로그인 시 jwt으로 사용자 인증을 관리하였고 role guard를 통해 몇몇 보안과 관련된 api는 관리자, 판매자만 접속할 수 있도록 인가를 구현</td>
    </tr>
    <tr>
      <td>Passport</td>
      <td>회원가입/소셜 로그인 기능 구현</td>
    </tr>
    <tr>
      <td>Toss API</td>
      <td>상품 결제 기능 구현</td>
    </tr>
    <tr>
      <td>Puppeteer</td>
      <td>데이터크롤링에는 동적 요소를 크롤링/스크래핑</td>
    </tr>
    <tr>
      <td>JMeter</td>
      <td>부하 테스트</td>
    </tr>
    <tr>
      <td>Docker</td>
      <td>팀원간의 일관성 있는 배포환경을 구축</td>
    </tr>
    <tr>
      <td>GitAction</td>
      <td>자동화된 CI/CD 프로세스 구현</td>
    </tr>
    <tr>
      <td>Winston</td>
      <td>로깅을 통해 사용자의 사용 패턴을 분석하고 에러 발생 시 즉각 대응</td>
    </tr>
    <tr>
      <td>ElasticSearch</td>
      <td>수집된 저장한 후 키바나와 연동</td>
    </tr>
    <tr>
      <td>Kibana</td>
      <td>로그를 시각화/분석</td>
    </tr>
  </tbody>
</table>
</details>

<br>

<details>
  <summary style="font-size: 30px;"><strong>📚 How to use</strong></summary>

  <details>
<summary style="font-size: 20px;"><strong>env</strong></summary>
<pre><code>  # Database
  DB_HOST = "DB URL"
  DB_PORT = "DB PROT"
  DB_USERNAME = "DB USERNAME"
  DB_PASSWORD = "DB PASSWORD"
  DB_NAME = "DB NAME"
  DB_SYNC = true
  PORT = 3000<br>
  # JWT Secret Key
  JWT_SECRET_KEY=""<br>
  # Redis Cloud
  REDIS_HOST = "DB URL"
  REDIS_PORT = "DB PORT"
  REDIS_USERNAME = "DB USERNAME"
  REDIS_PASSWORD = "DB PASSWORD"<br>
  # Kakao Auth
  KAKAO_KEY = ""
  KAKAO_CLIENT_SECRET = ""
  KAKAO_REDIRECT = ""# Naver Auth
  NAVER_CLIENT_ID = ""
  NAVER_CLIENT_SECRET = ""
  NAVER_CALLBACK_URL = ""<br>
  # Google Auth
  GOOGLE_CLIENT_ID = ""
  GOOGLE_CLIENT_SECRET = ""
  GOOGLE_CALLBACK_URL = ""<br>
  # Toss 테스트 키
  TOSS_TEST_KEY = "TOSS PAYMENT KEY"<br>
  # AWS S3
  AWS_ACCESS_KEY_ID = "AKIA5B2RRRTP5XD54K6Q"
  AWS_SECRET_ACCESS_KEY = "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"
  AWS_REGION = "ap-northeast-2"
  AWS_BUCKET_NAME = "visitor-gosagi"
</code></pre>
</details>

<details>
<summary style="font-size: 20px;"><strong>Install package</strong></summary><br>
<pre><code>npm i</code></pre>
</details>

<details>
<summary style="font-size: 20px;"><strong>Running the app</strong></summary>

#### development

<pre><code>$ npm run start</code></pre>

#### watch mode

<pre><code>$ npm run start:dev</code></pre>
</details>

</details>

<br>

<details>
  <summary style="font-size: 30px;"><strong>💬 기술적 의사결정</strong></summary>

<details markdown="1">
  <summary markdown="1" style="font-size: 20px;"><strong>📰 크롤링 라이브러리 선택(`Puppeteer`)</strong></summary>
  <div markdown="1">

### 1) 파이썬 라이브러리 vs 자바스크립트 라이브러리

- `파이썬의 장단점`

  - 장점
    - 배우기 쉽다 : ???
    - 라이브러리가 아주 많다
    - 절차적, 객체지향, 함수형, 관점형 프로그래밍이 모두 가능하다
    - 대규모 프로그램에 대한 이상적인 구조와 지원을 제공한다.
    - `Java`, `C` 및 `C ++` 프로그래밍 코드와 통합 가능하다.
      [JavaScript vs. Python](https://velog.io/@hyoniii_log/JavaScript-vs.-Python)
  - 단점

    - 속도

      - 파이썬은 다른 언어에 비해 `2~10배 정도 느리다.`
      - 여러가지 이유가 있지만 그 중 하나는 `dynamical type`이다.
      - 파이썬은 변수들의 데이터 타입을 정해줄 필요가 없다.
      - 파이썬이 알아서 그 일을 처리하는데 그 과정이 파이썬에게 큰 부담이 된다고 한다.
      - 그래서 프로젝트가 점점 커지고 소스 코드가 길어질수록 속도는 점점 느려진다.
      <aside>

      ```
      💡 결론 : 파이썬이 라이브러리가 더 많지만, 자바스크립트와 동일하게 다이나믹 타입이므로 속도상 나은 점은 없어보임, 유효한 라이브러리가 있다면 자바스크립트를 통해 진행하는 것이 유리할것으로 결정
      ```

    </aside>

  ### 2) **Cheerio** vs **Puppeteer**

- **Cheerio**
  - DOM 파서로서 HTML과 XML 파일을 파싱하는 데 탁월합니다.
  - <strong>`axios`</strong>와 같은 HTTP 클라이언트 라이브러리와 결합하여 사용됩니다.(단독사용불가)
  - 브라우저처럼 웹사이트를 렌더링하지 않아, CSS 적용이나 외부 리소스 로딩이 필요 없습니다.
  - 단순한 문법과 jQuery와 유사한 사용법으로 학습 곡선이 낮습니다.
  - <strong>`puppeteer`</strong>에 비해 속도가 매우 빠릅니다
- **Puppeteer**

  - 브라우저 자동화 도구로, 헤드리스 크롬 또는 크로미움을 제어합니다.
  - 자바스크립트 실행이 가능하여 동적인 웹 페이지 크롤링에 적합합니다.
  - 웹사이트와 상호작용하거나 로그인 폼, 스크립트 뒤의 콘텐츠에 접근할 수 있습니다.
  - 기능이 많고 <strong>`Async`</strong>를 사용해야 하므로 학습 곡선이 높습니다.
  - <strong>`cheerio`</strong>에 비해 상대적으로 느립니다

    <img src="./readme/Untitled 5.png">

  ```
  💡 크롤링 대상 사이트가 동적사이트로 밝혀짐
  Cheerio로 크롤링한 결과 변수명이 그대로 크롤링됨
  따라서 동적요소를 가져올 수 있는 Puppteer 채택
  ```

    </div>
  </details>

<details markdown="1">
  <summary markdown="1" style="font-size: 20px;"><strong>💡 로깅 시스템 `Winston` 도입</strong></summary>
  <div markdown="1">

### 1) 로깅 시스템 도입 이유

- 로깅 : 애플리케이션에서 발생하는 이벤트에 대한 기록!
- 로깅을 하면 사용자들이 자주 사용하는 기능을 찾아서 유저의 사용 패턴을 분석할 수 있고, 에러 로깅을 통해 에러가 발생한 지점을 파악하여 빠른 문제 해결이 가능합니다.
- 로그들을 파일에 기록하거나 DB에 저장한 후 통계를 내면 보다 나은 유지보수 진행할 수 있습니다.

### 2) NEST의 logger vs Sentry vs pino vs Winston

### NEST 자체의 logger

- nest 자체에서 제공하는 기능
  장점
  - 라이브러리를 설치하지 않아도 됨!
    단점
  - 로깅 옵션이 제한적이라 복잡한 로깅이 제한적임

### Sentry

- Sentry는 개발자가 애플리케이션에서 발생하는 에러와 예외를 실시간으로 추적하고, 분석할 수 있도록 도와주는 애플리케이션 모니터링 및 에러 추적 플랫폼
- 에러/버그 로깅에 집중
- 프론트 에러 로그 시스템이라는 제목이 많이 보임
  장점
  - 다양한 언어/프레임워크 지원
  - 에러에 대한 자세한 정보를 제공함
  - 애플리케이션의 성능 모니터링, 성능 저하가 예상되는 부분을 식별할 수 있
    단점
  - 많은 기능을 사용하려면 유로 플랜을 구독해야 한다고,,,
  - 에러가 Sentry 서버로 전송되어서 보안 이슈가 발생할 수 있

### pino

- node를 위한 매우 빠른 로깅 라이브러리
- 로그를 JSON 형식으로 출력함
- 사용 방법이 쉬운듯 ?
  장점
  - 많은 양의 로그를 효율적으로 처리 가능
  - 속도가 매우 빠름
    단점
  - 로그 레벨과 포맷 커스터마이징이 제한적일 수 있음

### `Winston`

- node에서 가장 유명한 로깅 라이브러리! (실제로 nest 로깅을 검색해보면 대부분이 nest의 로거를 잠깐 알려주고 winston을 사용하는 것을 볼 수 있음)
- 매우 강력한 로깅 기능 제공
  장점
  - 다양한 로깅 옵션/로깅 대상 제공
  - 커스터마이징이 용이하여 복잡한 로깅 요구 사항을 충족할 수 있음
    단점
  - 초기 설정이 복잡할 수 있음!
  - 로그 처리를 위한 오버헤드가 발생할 수 도..

```
💡 로그를 원하는 방식으로 커스터마이징 하고 빠른 시간 내에 많은 정보들을 확인할 수 있는 winston을 채택
```

  </div>
</details>

<details markdown="1">
  <summary markdown="1" style="font-size: 20px;"><strong>👨‍🔧 부하 테스트 `Jmeter` 도입</strong></summary>
  <div markdown="1">

### 1) 부하시스템 도입 이유

- 쇼핑몰은 한 상품에 인기에 따라서 트래픽이 대량 발생할 수 있는 서비스입니다.
- 따라서 일정한도수준의 트래픽을 가정하여 부하를 분산, 개선할 수 있는 시스템을 구축하려면 테스트를 위한 부하시스템을 갖출 필요성이 있었습니다.

### 2) Jmeter vs Ngrinder vs Gatling

- <strong>`Jmeter`</strong> ⭐⭐⭐⭐⭐
  - 접근성 ⭐⭐⭐⭐⭐
    - 설치도 쉽고 GUI로 구동되므로 사용하기 편함
    - 구동에 CLI, 코드가 필요없고 `**메뉴한글화**`도 되어있음(필요시 CLI로도 구동가능)
  - 기능성 ⭐⭐⭐⭐⭐
    - 다양한 기능을 지원(시나리오 생성 가능)
  - 데이터 ⭐⭐⭐⭐⭐
    - 열람 데이터 종류가 가장 많음
  - 보완성 ⭐⭐⭐⭐⭐
    - 방대한 커뮤니티를 가짐
- Ngrinder ⭐⭐⭐⭐
  - 접근성 ⭐⭐⭐⭐⭐
    - docker로 쉽게 설치, 이용 가능
    - GUI 기반으로 진행되나, 세부 구동시 테스트코드를 작성해야 함(`Groovy Scripts`)
    - 진짜 메뉴만 한글화됨(네이버에서 만들었다며)
  - 기능성 ⭐⭐⭐
    - 다양한 기능을 지원하기는 하지만 테스트코드가 익숙해진 후 활용해야함
    - 그에 비해 뒤에나오는 커뮤니티나 업데이트가 지속적으로 이루어지지는 않음
  - 데이터 ⭐⭐⭐
    - TPS기반의 그래프만 보여줌
    - 열심히 해석하면 되지만 종류는 국한됨
  - 보완성 ⭐⭐⭐
    - 상대적으로 적은 커뮤니티를 보유함
- Gatling ⭐⭐
  - 접근성 ⭐⭐⭐
    - CLI를 통해서만 테스트 가능함
    - 결과는 html로 그래프 화시켜준다는 점이 유일한 희망
  - 특이점 ⭐⭐
    - 성공을 OK, 실패를 KO로 표현함
    - Cnt/s 단위로 표현됨 Count of events per second
    - 그거말곤 장점이 뭔지 잘 모르겠음

```
💡 모든면에서 전반적으로 `Jmeter`가 우위에 있음으로 판단하고 Jmeter를 선택
```

</div></details>

<details markdown="1">
  <summary markdown="1" style="font-size: 20px;"><strong>📉 `Redis` > `Cookie` 다운그레이드</strong></summary>
  <div markdown="1">

### 최초의 선택 Redis

- 초기에 최근 본 상품에 대해 구현을 논의하면서 Cookie, Redis중에 고민하였음
- 최초에는 휘발성이 강한 DATA이지만 브라우저가 달라지더라도 한 유저에게 같은 값을 제공할 수 있는 Redis를 선택했음

### 받았던 피드백들

- 중간발표 후 Redis에 대한 피드백
    <aside>
    💡 쇼핑몰은 여러 상품을 검색하고 정보를 확인하는 과정이 무수히 반복 되는곳입니다. 최근 본 상품의 경우도 자주 바뀔 가능성이 높은데요. redis에 적재하는 이유가 있을까요? 다른 대안은 없을까요?
    
    </aside>

- 담당 튜터님의 피드백
    <aside>
    💡 상품 상세정보가 로그인한 유저에게만 오픈되어있는데 아닌 사람에게도 보여주는 것이 훨씬 서비스측면에서 좋을 것 같다.
    
    </aside>

### 재고민 후 Cookie선택

- 로그인 없이 디테일 페이지를 볼 수 있다면 비로그인 유저에게도 최근 본 상품 열람이 가능해져야함(기존 기능 수정이 불가피함)
- Cookie에 내역을 저장하면 클라이언트 단에서 최근 본 상품을 꺼내 쓸 수 있으며 Redis 자원은 더 유리한 곳에 사용할 수 있음
- 이미 본 서비스에 ‘찜’ 기능이 있어 관심가는 서비스를 기억할 수 있는 기능이 있으므로 굳이 브라우저가 달라지더라도 최근본 상품이 유저별 공유될 실익이 없다고 판단하였음

</div></details>
</details>

<br>

<details>
  <summary style="font-size: 30px;"><strong>💣트러블슈팅</strong></summary>
<details markdown="1">
  <summary markdown="1" style="font-size: 20px;"><strong>😤 몇 명까지 버틸 수 있을까? 대용량 트래픽 처리</strong></summary>
  <div markdown="1">

**🤒 문제 현상**

- 부하테스트 구축 후 실험결과 요청자수가 많아질수록 평균응답속도가 느려지고 에러율도 증가함
  - 에러가 날경우 서버에서는 요청이 왔는지도 인지하지 못하게 됨
    <img src="./readme/Untitled 6.png">

**🧐 발생 원인**

- **연결 시간 초과**, **서버 부하로 인한 소켓종료**
  ```json
  java.net.SocketException: Socket closed
  ```
- 연결 거부 오류

  ```json
  org.apache.http.conn.HttpHostConnectException: Connect to back.gosagi.com:443
  [back.gosagi.com/3.35.113.5, back.gosagi.com/54.180.0.249] failed: Connection timed out: connect
  ```

**🧐 해결 방안**

- 서버증설 및 로드밸런싱
  - 도커 컨테이너 추가를 통한 서버 증축
    <img src="./readme/Untitled 7.png">
- Docker에 Nginx컴포넌트 생성 및 부하 분산

  ```json
  worker_processes auto;

  events {
    worker_connections 1024;
  }

  http {
    upstream node-app {
      least_conn;
      server 43.201.114.107:3000 weight=10 max_fails=3 fail_timeout=30s;
      server 43.201.114.107:3001 weight=10 max_fails=3 fail_timeout=30s;

    }

    server {
      listen 80;
      server_name back.gosagi.com;

      location / {
        proxy_pass http://node-app;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
      }
    }
  }
  ```

**🫡 최종 결과**

| **2,000개 요청**                    | **3,000개 요청**                     | **4,000개 요청**                     |
| ----------------------------------- | ------------------------------------ | ------------------------------------ |
| 도입 이전                           | 도입 이전                            | 도입 이전                            |
| 3569ms                              | 4597ms                               | 12061ms                              |
| <img src="./readme/Untitled 8.png"> | <img src="./readme/Untitled 10.png"> | <img src="./readme/Untitled 12.png"> |
| 평균 응답시간 2208ms(대략 2초)      | 평균 응답시간 2162ms(대략2초)        | 평균 응답시간 6522ms(대략6초)        |
| 오류 발생 없음                      | 오류 발생 없음                       | 오류 11.9% 발생                      |
| <img src="./readme/Untitled 9.png"> | <img src="./readme/Untitled 11.png"> | <img src="./readme/Untitled 13.png"> |

</div>
</details>

<details>
<summary markdown="1" style="font-size: 20px;"><strong>😎 모든걸 한번에! 개발생산성 향상을 위한 CI/CD 체계 구축</strong></summary>
  <div markdown="1">

**🤒 문제 현상**

- 서비스 고도화에 따라 배포버전 변경시 더불어 진행해야 할 프로세스가 많아지는 문제 발생
- 프로젝트 효율을 증대시키기 위해 자동화의 필요성 발생

**🧐 발생 원인**

- 서비스 고도화에 따른 배포단계 복잡도 상승
- github merge ➡️ 서버에서의 리포지토리 full ➡️ docker이미지 생성 ➡️ 환경변수(.env) 전달 ➡️ docker 컨테이너 실행

**🧐 해결 방안**

- 다양한 자동화 툴 중 가장 유명한 젠킨스, GitAction 검토
- Jenkins 장단점
  - 파이프라인을 한곳에서 관리하기 편함, Private IP에서도 진행가능
  - 속도가 Github Action보다 빠름
  - 관련자료가 많은 편임
  - 초기 환경설정이 다소 복잡함
- GithubAction 장점
  - 관련자료가 상대적으로 적지만 초기 구성이 상대적으로 편리함
  - 초기 환경설정이 쉬움
  - **실시간 온라인으로 배포과정을 열람 가능**하여 에러핸들링에 용이

**🫡 최종 결정 : githubAction**

- github action이 초기구축이 용이하여 **배포단계 복잡도 감소라는 본목적 실현에 효율적**이라 판단
- 다양한 **기술을 구현 및 테스트**해보고 싶었던 프로젝트의 특징상 목적달성을 위한 구현시간 절감으로 개발생산성 향상 도모
- 향후 민감한 정보 등 Private IP를 사용할 시 젠킨스 등도 고려, 구현시도예정
  </details>

<details>
<summary markdown="1" style="font-size: 20px;"><strong>😋 더 가볍게! : Docker 이미지 경량화를 통한 서버 생산성 향상</strong></summary>
  <div markdown="1">

**🤒 문제 현상**

- 구축단계에서 지속적인 이미지 빌드, 서비스 규모 확장
- 개발자 PC, 서버 인트턴스 등 현 디바이스 수준에서 한계치에 도달하는 문제 발생

**🧐 발생 원인**

- 프리티어 서버의 CPU, 메모리 한계
- 견습용 개발자 디바이스의 저장용량, 메모리 한계

**🧐 해결 과정**

- 알파인 이미지 확인 후 시도 : 컨테이너 내부에서 사용하기 위해 제작된 운영체제인 알파인 리눅스 프로젝트를 기반으로 하는이미지
- 다단계빌드 확인 후 시도
  - 여러 단계의 빌드 단계를 만들고, 다른 단계의 결과물에서 특정 폴더만 복사 가능하여 이미지 경량화 가능

**🫡 개선 결과**

| **초기 이미지(구동전, `1.61G 용량`)** | **알파인 이미지(구동전, 917MB 용량)** | **다단계 빌드(구동전, `293MB 용량`)** |
| ------------------------------------- | ------------------------------------- | ------------------------------------- |
| <img src="./readme/Untitled 14.png">  | <img src="./readme/Untitled 16.png">  | <img src="./readme/Untitled 18.png">  |
| **메모리 사용 : 388MB**               | **메모리 사용 : 292MB**               | **메모리 사용 : `161MB`**             |
| <img src="./readme/Untitled 15.png">  | <img src="./readme/Untitled 17.png">  | <img src="./readme/Untitled 19.png">  |

</details>

<details>
<summary markdown="1" style="font-size: 20px;"><strong>🤩 어플리케이션 실행오류까지 포함된 전역 로깅 구축</strong></summary>
  <div markdown="1">

**🤒 문제 현상**

- `Winston`으로 에러 로깅할 때 애플리케이션 실행 시 발생하는 에러(DB 연결 등)이 기록되지 않음
- 로깅은 지속적으로 쌓는데 성공했으나 로깅 데이터를 관리, 분석하는 필요성이 생김

**🧐 발생 원인**

- 로깅을 미들웨어에서 진행하고 있는데 애플리케이션이 실행되기 전에는 미들웨어를 거치지 않기 때문
- `Winston` 라이브러리는 로깅을 상세하게 커스터마이징 할 수는 있지만 분석까지 해주는 도구는 아님

**🧐 해결 과정**

- `main.ts`에서 전역 필터를 걸어 애플리케이션 실행을 포함한 전역에서 발생하는 로그 수집 가능해짐

<img src="./readme/Untitled 20.png">

- `Winston` 라이브러리를 이용해 추출한 로그를 `winston-elasticsearch` 라이브러리를 통해 `Elasticsearch` 에 저장 후 `Kibana`를 통해 분석, 열람하도록 시스템 구축(`elastic cloud`를 이용하였음)

<img src="./readme/Untitled 21.png">

**🫡 개선 결과**

<img src="./readme/Untitled 22.png">

- 로그를 호출 수 별로 정리하여 확인할 수 있도록 `데이터 축적` ➡️ `저장` ➡️ `분석` ➡️ `시각화`까지 연결
  </details>

</details>

<br>

<details>
  <summary style="font-size: 30px;"><strong>😤 추후 개발 및 기술적인 도획</strong></summary>

- `DB`는 `분산`을 해보지 못해서 추후 docker활용해 분산 및 동시성 제어를 위한 `분산 락`을 경험해보고 싶습니다.
- 개발 단계에서 `테스트 코드`를 조금 더 상세하게 공부해보고 싶다.
- 로깅 시스템을 `엘라스틱 서치`를 적용해서 좀더 `심화적으로 관리`해보고 싶다.
- `검색어 순위별` 정리하는 기능을 구현해보고 싶다.
</details>

<br>

<details>
  <summary style="font-size: 30px;"><strong>🙌🏻 팀 구성</strong></summary>

## 정창일 (**[🔗깃허브](https://github.com/visitor17564) / [🔗블로그](https://www.notion.so/Visitor-s-TIL-BLOG-db04ff434b18402880802a1350303e15?pvs=21))**

👤 **포지션** : 리더, **기획** 전반, 프론트앤드, **버그픽스**

🔧 **주요 작업**

- 프론트앤드 설계 및 백앤드 연결작업 전반
- 프론트/백앤드 버그픽스 전반
- S3 활용한 파일 업로드
- Nest.js 백앤드 API 제작 : store
- 크롤링 구조 구축 지원 : Puppteer

🖥️ **주요 사용기술**

| Puppeteer | ngrinder | Jmeter     | aws S3   | rds |
| --------- | -------- | ---------- | -------- | --- |
| HTML      | CSS      | Javascript | Tailwind |     |

## 이아영 (**[🔗깃허브](https://github.com/ay0530) / [🔗블로그](https://velog.io/@ay0530/posts))**

👤 **포지션** : 부리더, **로깅 프로세스 담당**, 백앤드 구현, 프론트앤드 지원

🔧 **주요 작업**

- **log 데이터 수집, 관리, 시각화** 작업 : winston ➡️ ElasticSearch ➡️ Kibana 연동
- **캐시DB** 활용한 리프레시토큰 관리 : **redis**
- **크롤링** 구조 구축 : Puppteer
- Nest.js 백앤드 API 제작 : user, auth(jwt), store, question, answer
- 프론트앤드 설계 및 백앤드 연결작업 지원

🖥️ **주요 사용기술**

| winston    | ElasticSearch | Kibana | Nestjs | Puppeteer | redis | Typescript |
| ---------- | ------------- | ------ | ------ | --------- | ----- | ---------- |
| Javascript | Tailwind      | HTML   | CSS    |           |       |            |

## 권유진 (**[🔗깃허브](https://github.com/asdfg20564) / [🔗블로그](https://smy1308.tistory.com/))**

👤 **포지션** : 팀원, **로깅 프로세스 담당**, 백앤드 구현

🔧 **주요 작업**

- **log 데이터 수집, 관리, 시각화** 작업 : winston ➡️ ElasticSearch ➡️ Kibana 연동
- Nest.js 백앤드 API 제작 : order, wish, review, cart, guard
- 이미지 파일 압축을 통한 프론트 로딩시간 단축
- 백앤드 버그픽스 전반

🖥️ **주요 사용기술**

| winston    | ElasticSearch | Kibana | Nestjs | Typescript | redis |
| ---------- | ------------- | ------ | ------ | ---------- | ----- |
| Javascript | HTML          | CSS    |        |            |       |

## 하정현 (**🔗깃허브 / [🔗블로그](https://velog.io/@zmjjkk98/posts))**

👤 **포지션** : 팀원, **CI/CD 담당**, **대용량 트래픽 관리**, **부하테스트 담당**, 백앤드 구현

🔧 **주요 작업**

- Nest.js 백앤드 API 제작 : product
- Passport 활용한 SNS 로그인 구축(Naver, Google)
- **docker** 서버환경 구축 : NGINX ➡️ \*\*\*\*ELB ➡️ Ec2 ➡️ docker
- NGINX 로드밸런싱을 통한 **대용량 트래픽 관리**
- merge와 동시에 **자동으로 배포되는 CI/CD 구축** : githubAction - docker 활용
- Gatling 활용한 부하테스트 환경 구축 및 실험
- 크롤링 구조 구축 지원 : Puppteer

🖥️ **주요 사용기술**

| docker | NGINX      | AWS Elastic Load Balancer(ELB) | Nestjs | Typescript |
| ------ | ---------- | ------------------------------ | ------ | ---------- |
| Ec2    | Javascript | githubAction                   |        |            |

## 손민영 (**[🔗깃허브](https://github.com/smy1308) / [🔗블로그](https://smy1308.tistory.com/))**

👤 **포지션** : 팀원, **CI/CD 담당**, **부하테스트 담당**, 백앤드 구현

🔧 **주요 작업**

- Nest.js 백앤드 API 제작 : FAQ, Address CRUD
- Passport 활용한 SNS 로그인 구축(Kakao)
- **docker** 서버환경 구축 지원 : NGINX ➡️ \*\*\*\*ELB ➡️ Ec2 ➡️ docker
- 다단계빌드 구축을 통한 **docker이미지 경량화**
- merge와 동시에 **자동으로 배포되는 CI/CD 구축** : githubAction - docker 활용
- Jmeter 활용한 **부하테스트 환경 구축 및 자료관리**

🖥️ **주요 사용기술**

| docker | Nestjs       | Typescript | Jmeter |
| ------ | ------------ | ---------- | ------ |
| Ec2    | githubAction | Javascript |        |

</details>

<br>

<details>
  <summary style="font-size: 30px;"><strong>🥹 최종 프로젝트 회고</strong></summary>

### 정창일

- 🫡 **좋았던 부분 :** API등의 단순 구현보다 좀더 **백앤드적인 시도를 경험 하는 쪽으로 방향을 정하고 진행**한 것이 오히려 짧은 기간 각자에게 더 큰 도움이 되었다고 생각합니다.
- 🤒 **아쉬운 부분 :** 처음 시도해보는 것들이었다보니 백앤드적 컨텐츠의 **심화적인 요소를 고민하는 것보다** 기능 자체를 **구현하는 데 시간이 더 많이 쓰였던게** 아쉽습니다.
  좀더 전체적인 흐름을 이해하고 다양한 상황에 맞춰 개념들을 활용할 수 있도록 공부하고 싶습니다.

### 이아영

- 🫡 **좋았던 부분 :** 팀장님을 통해 노션으로 일정, 업무 등을 정리하는 방법을 배웠고 팀원분들과의 협업을 통해 여러 기능을 학습할 수 있어서 좋았습니다. 그리고 공식 문서가 중요하다는 것을 뼈저리게 느낄 수 있었습니다 땡큐!
- 🤒 **아쉬운 부분 :** 지금까지 구현해보지 않았던 기능들을 제작하다보니 내가 진행하는 방향이 맞는지 확인되지 않은 채로 공식문서, 여러 글을 보면서 많은 시간을 소요한 것과 제 업무를 처리하느라 다른 팀원분들의 작업을 제대로 확인하지 못 한 것이 아쉽습니다.

### 권유진

- 🫡 **좋았던 부분 :** 매일매일 열심히 해주시고 묻거나 찾을 때 즉각 나타나셔서 같이 팁들 공유해주셔서 정말 좋았습니다. 많이 발전할 수 있었던 것 같고 묵묵한 노력 덕에 최종발표까지 달릴 수 있었다고 생각합니다.
- 🤒 **아쉬운 부분 :** 취업활동을 동시에 하느라 심화 구현에 시간을 많이 쓰지 못해서 미안하였고, 완성까지 그나마 안정적이어서 다행이었지만, 조금 더 열의를 불태워 어려운 것에 도전해 보는 것도 좋은 경험이었을 것이라 생각합니다.

### 하정현

- 🫡 **좋았던 부분 :** 맡은 역할에 대해 다들 120%이상 해주신것 같아서 좋았고, 개발에 있어서 다양하게 생각하지 못했던 부분이나 잘 몰랐던 부분들을 공유 받을 수 있어서 좋았습니다.
- 🤒 **아쉬운 부분 :** 구현 했던 기능에 대해 정답지가 없다보니, 더 나은 방법이 없었는지 아니면 어떤 부분이 안좋은 방법인지 알려주는 사람이 없으니 아쉬웠습니다.

### 손민영

- 🫡 **좋았던 부분 :** 일정공유와 회의록 작성 등 프로젝트 **진행 기록을 자세하게 한것**이 굉장히 잘한 부분이라고 생각하고, **일정조율**도 잘 진행되었다고 생각합니다.
- 🤒 **아쉬운 부분 :** 아쉬운것은 시간을 들여 심화공부가 필요한 부분들이 있어 **좀 더 도전적인 기술을 구현하지 못했다는 것**이 아쉽습니다.
</details>
